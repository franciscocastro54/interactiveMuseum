<!DOCTYPE html>
<html lang="en">
<head>
  <title>Cards con video en sección (ReadyPlayerMe + Three.js WebGPU)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; overflow: hidden; background: #000; }
    #help { position: fixed; left: 12px; bottom: 12px; color: #fff; font: 12px/1.45 system-ui, sans-serif; background: rgba(0,0,0,.35); padding: 10px 12px; border-radius: 8px; backdrop-filter: blur(6px); }
    #help kbd { background: rgba(255,255,255,.15); padding: 2px 6px; border-radius: 4px; }
    /* === Mobile controls === */
    #mobileControls { position: fixed; inset: 0; pointer-events: none; z-index: 20; }
    #mobileControls.hidden { display:none; }

    .joy {
      position: absolute; width: 140px; height: 140px; border-radius: 50%;
      background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.15);
      pointer-events: auto; touch-action: none; backdrop-filter: blur(6px);
    }
    .joy .knob {
      position: absolute; left: 50%; top: 50%;
      width: 64px; height: 64px; margin-left:-32px; margin-top:-32px;
      border-radius: 50%; background: rgba(255,255,255,.18); border:1px solid rgba(255,255,255,.25);
    }

    #joyL { left: 16px; bottom: 16px; }
    #joyR { right: 16px; bottom: 16px; }

    .mobBtn {
      position: absolute; right: 24px; bottom: 180px; pointer-events: auto; touch-action: manipulation;
      background: rgba(0,128,255,.25); color: #fff; border: 1px solid rgba(255,255,255,.25);
      padding: 10px 14px; border-radius: 10px; font-weight: 600; backdrop-filter: blur(6px);
    }

  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.webgpu.js",
        "three/webgpu": "./build/three.webgpu.js",
        "three/tsl": "./build/three.tsl.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="help">
    <div><strong>Controles</strong></div>
    <div><kbd>W</kbd> caminar · <kbd>Shift+W</kbd> correr · <kbd>S</kbd> retroceder</div>
    <div><kbd>A</kbd>/<kbd>D</kbd> girar continuamente</div>
    <div>Click en "Visitar" abre el link</div>
  </div>

  <div id="mobileControls" class="hidden">
  <div id="joyL" class="joy"><div class="knob"></div></div>
  <div id="joyR" class="joy"><div class="knob"></div></div>
  <button id="btnRun" class="mobBtn">RUN</button>
</div>


  <script type="module">
    import * as THREE from 'three';
    import { screenUV, color, vec2, vec4, reflector, positionWorld } from 'three/tsl';
    import Stats from 'three/addons/libs/stats.module.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Config animaciones
    const animationsToLoad = [
      { name: 'Idle', path: './animations/StandingW_BriefcaseIdle.fbx' },
      { name: 'Walk', path: './animations/Walking.fbx' },
      { name: 'Run', path: './animations/Running.fbx' },
      { name: 'Backwards', path: './animations/WalkingBackwards.fbx' }
    ];
    const WALK_SPEED = 1.4, RUN_SPEED = 3.2, BACK_SPEED = 1.2;
    const ROT_SPEED = THREE.MathUtils.degToRad(180);
    const CAM_LOOK_AT = new THREE.Vector3(0, 1.3, 0);

    // ================================
    // CONFIGURA TUS RUTAS (MODELO GLB + TEXTURAS)
    // ================================
    const MODEL_URL   = './models/meta-quest-3/source/Quest3.glb';
    const TEX_BASE_1  = './models/meta-quest-3/textures/Image_0_0.png';
    const TEX_BASE_2  = './models/meta-quest-3/textures/Image_2_2.png';
    const TEX_AO_R    = './models/meta-quest-3/textures/Image_1_1@channels=R.png';
    const TEX_ROUGH_G = './models/meta-quest-3/textures/Image_1_1@channels=G.png';
    const TEX_METAL_B = './models/meta-quest-3/textures/Image_1_1@channels=B.png';
    const MODEL_TARGET_HEIGHT = 0.5;
    const MODEL_POSITION = new THREE.Vector3(1.2, 1.4, 1);
    const MODEL_ROT_DEGS_PER_SEC = 30;

    // --- Estado general
    const clock = new THREE.Clock();
    const stats = new Stats(); document.body.appendChild(stats.dom);
    const keys = { w: false, a: false, s: false, d: false, shift: false };
    let scene, camera, renderer, controls;
    let avatarRoot = null, mixer = null, actions = {}, current = 'Idle';

    // ===== Escena base =====
    scene = new THREE.Scene();
    scene.backgroundNode = screenUV.x.mix(color(0x10131d), color(0x221634)).add(screenUV.distance(vec2(0.5, 1.0)).oneMinus().mul(color(0x0c5d68)));
    scene.add(new THREE.HemisphereLight(0x99aaff, 0x223344, 6));
    const key = new THREE.DirectionalLight(0xffffff, 6); key.position.set(3, 6, 3); scene.add(key);
    const rim = new THREE.DirectionalLight(0x88bbff, 4); rim.position.set(-3, 5, -4); scene.add(rim);

    camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 2.6, 6);

    renderer = new THREE.WebGPURenderer({ antialias: true });
    renderer.toneMapping = THREE.NeutralToneMapping;
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Piso reflectante suave
    {
      const refl = reflector(); refl.target.rotateX(-Math.PI / 2); scene.add(refl.target);
      const reflMask = positionWorld.xz.distance(0).mul(.08).clamp().oneMinus();
      const floorMat = new THREE.NodeMaterial();
      floorMat.colorNode = vec4(refl.rgb, reflMask);
      floorMat.opacity = .2; floorMat.transparent = true;
      const floor = new THREE.Mesh(new THREE.BoxGeometry(60, .002, 60), floorMat);
      floor.position.y = 0; floor.receiveShadow = true; scene.add(floor);
    }

    // Controles de cámara
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.enablePan = false; controls.minDistance = 2.5; controls.maxDistance = 6;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Cubo demo
    let cube; {
      const g = new THREE.BoxGeometry(2,1.1,2);
      const m = new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 0.1, roughness: 0.6 });
      cube = new THREE.Mesh(g,m); cube.position.set(1.2,0.5,1); scene.add(cube);
    }

    // ====== util video robusto ======
    function ensurePlaying(video) {
      if (!video) return;
      video.muted = true;
      video.loop = true;
      video.preload = 'auto';
      video.playsInline = true;

      const tryPlay = () => video.play().catch(()=>{ /* espera a gesto */ });
      if (video.readyState >= 2) tryPlay(); // metadata lista
      video.addEventListener('loadeddata', tryPlay, { once: true });
      video.addEventListener('suspend', tryPlay);
      video.addEventListener('stalled', tryPlay);
      video.addEventListener('pause', tryPlay);
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) tryPlay();
      });
      // Primer gesto del usuario
      const resumeAll = () => { tryPlay(); window.removeEventListener('pointerdown', resumeAll); };
      window.addEventListener('pointerdown', resumeAll);
    }

    // ===== Galería (cards) =====
    const GALLERY = new THREE.Group(); scene.add(GALLERY);

    const WALL = { position: new THREE.Vector3(0, 3, -6), normal: new THREE.Vector3(0,0,1), width: 90, height: 6, margin: 0.002 };
    function wallFrame(normal){ const n=normal.clone().normalize(); const up=Math.abs(n.y)>0.95?new THREE.Vector3(0,0,1):new THREE.Vector3(0,1,0); const u=new THREE.Vector3().crossVectors(up,n).normalize(); const v=new THREE.Vector3().crossVectors(n,u).normalize(); return {u,v,n}; }
    function wallQuat(normal){ const {u,v,n}=wallFrame(normal); const m=new THREE.Matrix4().makeBasis(u,v,n); return new THREE.Quaternion().setFromRotationMatrix(m); }
    const WALL_FRAME = wallFrame(WALL.normal);
    const WALL_QUAT = wallQuat(WALL.normal);

    // pared visible opcional
    {
      const pg = new THREE.PlaneGeometry(WALL.width, WALL.height);
      const pm = new THREE.MeshStandardMaterial({ color: 0x171a20, roughness: 0.95 });
      const plane = new THREE.Mesh(pg, pm); plane.quaternion.copy(WALL_QUAT); plane.position.copy(WALL.position); scene.add(plane);
    }

    // -- utilidades canvas
    function wrap(ctx, text, maxW){ if(!text) return []; const words=text.split(/\s+/); const out=[]; let line=''; for(const w of words){ const test=line?line+' '+w:w; if(ctx.measureText(test).width<=maxW) line=test; else { if(line) out.push(line); line=w; } } if(line) out.push(line); return out; }
    function roundRect(ctx,x,y,w,h,r,fill){ const rr=Math.min(r,w/2,h/2); ctx.save(); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fillStyle=fill; ctx.fill(); ctx.restore(); }

    // Carga media (imagen o mp4)
    function loadMedia(src){
      return new Promise((res,rej)=>{
        const isVideo=/\.mp4($|\?|#)/i.test(src);
        if(isVideo){
          const video=document.createElement('video');
          video.src=src;
          video.crossOrigin='anonymous';
          video.muted=true; video.loop=true; video.playsInline=true; video.preload='auto';
          const onReady=()=>{
            if(video.videoWidth>0 && video.videoHeight>0){
              ensurePlaying(video);
              res({type:'video', media:video, width:video.videoWidth, height:video.videoHeight});
              cleanup();
            }
          };
          const onError=e=>{ cleanup(); rej(e); };
          const cleanup=()=>{ video.removeEventListener('loadedmetadata',onReady); video.removeEventListener('loadeddata',onReady); video.removeEventListener('error',onError); };
          video.addEventListener('loadedmetadata',onReady);
          video.addEventListener('loadeddata',onReady);
          video.addEventListener('error',onError);
        } else {
          const img=new Image();
          img.decoding='async';
          img.crossOrigin='anonymous';
          img.onload=()=>res({type:'image', media:img, width:img.width, height:img.height});
          img.onerror=rej;
          img.src=src;
        }
      });
    }

    // Construye canvas de la tarjeta (sin pintar video en él). Devuelve rect para video y metadatos.
    async function buildCardCanvas({ title='Sin título', description='', image, link }){
      const mediaRes = await loadMedia(image);
      const { type, media, width: mw, height: mh } = mediaRes;

      const PX=1024, PADDING=32, TITLE=70, DESC=40, GAP=18;
      const BG='#101014', FG='#eaeaea', SUB='#b8c2cc';
      const maxW = PX - PADDING*2;

      const c=document.createElement('canvas');
      const ctx=c.getContext('2d');
      ctx.font=`700 ${TITLE}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
      const titleH=TITLE*1.3;
      ctx.font=`400 ${DESC}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
      const lines=wrap(ctx, description, maxW);
      const descH=lines.length? lines.length*(DESC*1.35):0;

      // calcular rect del media (contain)
      const maxH=Math.round(PX*0.56);
      const scale=Math.min(maxW/mw, maxH/mh);
      const drawW=Math.max(1, Math.round(mw*scale));
      const drawH=Math.max(1, Math.round(mh*scale));

      // alto total
      let H = PADDING + titleH + (description? descH+GAP : GAP) + drawH + PADDING;
      const HAS_LINK = !!link; const BTN_W=260, BTN_H=80, BTN_GAP=20, BTN_RADIUS=16;
      if (HAS_LINK) H += BTN_GAP + BTN_H;

      c.width=PX; c.height=H;

      // fondo tarjeta
      roundRect(ctx,0,0,PX,H,24,BG);

      // título
      ctx.font=`700 ${TITLE}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`; ctx.fillStyle=FG; ctx.textBaseline='top';
      ctx.fillText(title, PADDING, PADDING);

      // descripción
      let y=PADDING+titleH;
      if(description){ ctx.font=`400 ${DESC}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`; ctx.fillStyle=SUB; for(const s of lines){ ctx.fillText(s, PADDING, y); y += DESC*1.35; } y += GAP; } else { y += GAP; }

      // placeholder media
      const xImg=Math.floor((PX-drawW)/2), yImg=y;
      ctx.fillStyle='#0b0b0f'; ctx.fillRect(PADDING, yImg, PX-PADDING*2, drawH);
      if (type==='image') { ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; ctx.drawImage(media, 0,0,mw,mh, xImg,yImg,drawW,drawH); }

      // botón si hay link
      let buttonRect=null;
      if (HAS_LINK){
        const bx=Math.floor((PX-BTN_W)/2), by=yImg+drawH+BTN_GAP;
        roundRect(ctx,bx,by,BTN_W,BTN_H,BTN_RADIUS,'#2563eb');
        ctx.fillStyle='#fff'; ctx.font=`700 42px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        ctx.textBaseline='middle'; ctx.textAlign='center'; ctx.fillText('Visitar', bx+BTN_W/2, by+BTN_H/2);
        buttonRect={x:bx,y:by,w:BTN_W,h:BTN_H};
      }

      const mediaRect = { x:xImg, y:yImg, w:drawW, h:drawH, mw, mh };
      return { canvas:c, ctx, aspect: c.width/c.height, buttonRect, canvasSize:{w:c.width,h:c.height}, mediaRect, isVideo: (type==='video'), video: (type==='video'? media : null) };
    }

    // Crea el mesh de la tarjeta + marco, y si es video añade un plano hijo con VideoTexture
    function createCardMesh(baseCanvas, aspect, heightMeters, meta){
      const { canvasSize, buttonRect, mediaRect, isVideo, video } = meta;
      const widthMeters = heightMeters * aspect;

      // Material de la tarjeta (CanvasTexture)
      const tex = new THREE.CanvasTexture(baseCanvas);
      tex.colorSpace = THREE.SRGBColorSpace; tex.generateMipmaps = true; tex.needsUpdate = true;
      const cardMat = new THREE.MeshPhysicalMaterial({ map: tex, transparent: true, roughness: 0.6 });
      const cardGeo = new THREE.PlaneGeometry(widthMeters, heightMeters);
      const card = new THREE.Mesh(cardGeo, cardMat); card.position.z = 0.011;

      // Marco
      const plate = new THREE.Mesh(
        new THREE.BoxGeometry(widthMeters + 0.06*2, heightMeters + 0.06*2, 0.02),
        new THREE.MeshPhysicalMaterial({ color: 0x2a2d36, roughness: 0.85, metalness: 0.04 })
      );

      const group = new THREE.Group(); group.add(plate); group.add(card);
      group.userData.card = card;
      group.userData.canvasSize = canvasSize;
      group.userData.buttonRect = buttonRect;
      group.userData.cardTexture = tex;

      if (isVideo && video && mediaRect){
        const vw = widthMeters * (mediaRect.w / canvasSize.w);
        const vh = heightMeters * (mediaRect.h / canvasSize.h);
        const cx = widthMeters * (-0.5 + (mediaRect.x + mediaRect.w/2) / canvasSize.w);
        const cy = heightMeters * ( 0.5 - (mediaRect.y + mediaRect.h/2) / canvasSize.h );

        const vGeo = new THREE.PlaneGeometry(vw, vh);
        const vTex = new THREE.VideoTexture(video);
        vTex.colorSpace = THREE.SRGBColorSpace;
        vTex.minFilter = THREE.LinearFilter; vTex.magFilter = THREE.LinearFilter;
        vTex.generateMipmaps = false;

        const vMat = new THREE.MeshBasicMaterial({ map: vTex, toneMapped: false });
        const vMesh = new THREE.Mesh(vGeo, vMat);
        vMesh.position.set(cx, cy, 0.0125);
        group.add(vMesh);

        // Guardamos referencias y un flag para reconectar map de forma segura
        group.userData.videoMesh = vMesh;
        group.userData.videoTexture = vTex;
        group.userData.videoMapAttached = true;
        group.userData.videoElement = video;
      }

      return group;
    }

    // Posiciones de ejemplo en la pared
    const GALLERY_PLACES = [ {x:-28,y:-0.1,h:3.5},{x:-21,y:-0.1,h:3.5},{x:-14,y:-0.1,h:3.5},{x:-7,y:-0.1,h:3.5}, {x:0,y:-0.1,h:3.5}, {x:7,y:-0.1,h:3.5},{x:14,y:-0.1,h:3.5},{x:21,y:-0.1,h:3.5},{x:28,y:-0.1,h:3.5},{x:35,y:-0.1,h:2} ];
    function clampToWall(x,y){ const hw=WALL.width/2, hh=WALL.height/2; return { x:THREE.MathUtils.clamp(x,-hw+0.01,hw-0.01), y:THREE.MathUtils.clamp(y,-hh+0.01,hh-0.01) }; }

    // Carga de datos para cards
    (async function loadGallery(){
      let cards;
      try { const r=await fetch('./cards.json'); if(!r.ok) throw 0; cards=await r.json(); }
      catch {
        cards = [
          { title:'Video Demo', description:'Video embebido en la tarjeta', image:'https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4', link:'https://developer.mozilla.org/' },
          { title:'Imagen Demo', description:'Imagen estática', image:'https://picsum.photos/seed/a/1200/800', link:'https://threejs.org/' },
          { title:'Otra Imagen', description:'Card adicional', image:'https://picsum.photos/seed/b/900/1200' }
        ];
      }

      const q = WALL_QUAT;
      for (let i=0; i<cards.length; i++){
        const data = cards[i];
        const place = GALLERY_PLACES[i] || {x:0,y:0,h:2};
        const { x, y } = clampToWall(place.x, place.y);

        const cardData = await buildCardCanvas(data);
        const mesh = createCardMesh(cardData.canvas, cardData.aspect, place.h, {
          canvasSize: cardData.canvasSize,
          buttonRect: cardData.buttonRect,
          mediaRect: cardData.mediaRect,
          isVideo: cardData.isVideo,
          video: cardData.video
        });
        mesh.userData.link = data.link || null;

        mesh.quaternion.copy(q);
        mesh.position.copy( new THREE.Vector3().copy(WALL.position).addScaledVector(WALL_FRAME.u, x).addScaledVector(WALL_FRAME.v, y).addScaledVector(WALL_FRAME.n, WALL.margin) );
        GALLERY.add(mesh);
      }
    })();

    // Interacción (hover/click solo en botón)
    const G_RAY = new THREE.Raycaster();
    const G_PTR = new THREE.Vector2();
    let G_HOVER = null;
    renderer.domElement.addEventListener('pointermove', (e)=>{
      const r=renderer.domElement.getBoundingClientRect();
      G_PTR.x=((e.clientX-r.left)/r.width)*2-1; G_PTR.y=-((e.clientY-r.top)/r.height)*2+1;
    }, {passive:true});

    function hitButton(group){
      if(!group?.userData?.link || !group.userData.buttonRect || !group.userData.canvasSize) return false;
      const card = group.userData.card; if(!card) return false;
      G_RAY.setFromCamera(G_PTR, camera);
      const ih = G_RAY.intersectObject(card, true)[0];
      if(!ih || !ih.uv) return false;
      const {x:u, y:v} = ih.uv; const {w:W, h:H} = group.userData.canvasSize;
      const px=u*W; const py=(1-v)*H; const br=group.userData.buttonRect;
      return px>=br.x && px<=br.x+br.w && py>=br.y && py<=br.y+br.h;
    }

    renderer.domElement.addEventListener('click', ()=>{ if(G_HOVER && hitButton(G_HOVER)) window.open(G_HOVER.userData.link,'_blank','noopener'); });

    function updateInteractions(){
      G_RAY.setFromCamera(G_PTR, camera);
      const hits=G_RAY.intersectObjects(GALLERY.children, true);
      let group=null; if(hits.length){ let o=hits[0].object; while(o && o.parent && o.type!=='Group') o=o.parent; if(o && o.type==='Group') group=o; }
      if(G_HOVER && G_HOVER!==group){ G_HOVER.scale.set(1,1,1); document.body.style.cursor='default'; G_HOVER=null; }
      if(group){ G_HOVER=group; G_HOVER.scale.set(1.04,1.04,1.02); document.body.style.cursor=hitButton(G_HOVER)?'pointer':'default'; }
    }

    // ====== AVATAR ReadyPlayerMe ======
    (async()=>{
      const gltf = await new GLTFLoader().loadAsync('./models/ready_franciscoCastro.glb');
      avatarRoot = new THREE.Group(); avatarRoot.add(gltf.scene); scene.add(avatarRoot);
      gltf.scene.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
      const targetSkin=(function find(root){let f=null; root.traverse(o=>{ if(!f && o.isSkinnedMesh) f=o; }); return f;})(gltf.scene);
      controls.target.copy(avatarRoot.position).add(CAM_LOOK_AT);
      mixer = new THREE.AnimationMixer(targetSkin);
      const fbxLoader = new FBXLoader();
      for(const entry of animationsToLoad){
        try{
          const fbx=await fbxLoader.loadAsync(entry.path);
          const srcHelper=new THREE.SkeletonHelper(fbx); const srcSkeleton=new THREE.Skeleton(srcHelper.bones);
          const srcClip=fbx.animations?.[0]; if(!srcClip) continue;
          const ret=SkeletonUtils.retargetClip(targetSkin, srcSkeleton, srcClip, { hip:'mixamorigHips', scale:0.01, getBoneName:b=>'mixamorig'+b.name });
          ret.name=entry.name;
          const act=mixer.clipAction(ret); act.enabled=true; act.weight=0.0; act.loop=THREE.LoopRepeat; actions[entry.name]=act;
        }catch(e){ console.warn('Error anim', entry.path, e); }
      }
      current = actions['Idle'] ? 'Idle' : Object.keys(actions)[0] || 'Idle';
      if(actions[current]) actions[current].reset().setEffectiveWeight(1).play();
    })();

    // ====== MODELO GLB (rotación + texturas correctas) ======
    const gltfLoader = new GLTFLoader();
    const texLoader = new THREE.TextureLoader();
    let rotatingModelGroup = null;

    function tryLoadTexture(url, colorSpace = null, flipY = false) {
      return new Promise(resolve => {
        texLoader.load(url, t => {
          if (colorSpace) t.colorSpace = colorSpace;
          t.flipY = flipY;
          resolve(t);
        }, undefined, () => resolve(null));
      });
    }

    function debugMaterials(root) {
      root.traverse(o => {
        if (!o.isMesh) return;
        const m = o.material;
        if (!m) return;
        console.group(`Mesh: ${o.name || '(sin nombre)'} | Mat: ${m.name} (${m.type})`);
        const dump = k => {
          const tex = m[k];
          if (!tex) return;
          const src = tex.image?.src || tex.source?.data?.src || tex.name || '(embebida)';
          console.log(`${k}:`, src);
        };
        ['map','aoMap','roughnessMap','metalnessMap','normalMap','emissiveMap','alphaMap'].forEach(dump);
        console.groupEnd();
      });
    }

    async function loadRotatingModel() {
      const gltf = await gltfLoader.loadAsync(MODEL_URL);
      const root = gltf.scene;

      // Respetar materiales originales. Ajuste de espacios/UVs y sombras.
      root.traverse(o => {
        if (!o.isMesh) return;
        const m = o.material;
        if (m) {
          if (m.map) m.map.colorSpace = THREE.SRGBColorSpace;
          if (o.geometry && !o.geometry.attributes.uv2 && o.geometry.attributes.uv) {
            o.geometry.setAttribute('uv2', o.geometry.attributes.uv);
          }
        }
        o.castShadow = true;
        o.receiveShadow = true;
      });

      // Normalizar tamaño y apoyar en el piso
      const box = new THREE.Box3().setFromObject(root);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      const scale = MODEL_TARGET_HEIGHT / (size.y || Math.max(size.x, size.z) || 1);
      root.scale.setScalar(scale);
      box.setFromObject(root); box.getSize(size); box.getCenter(center);
      root.position.sub(center);
      root.position.y += size.y * 0.5;

      // Agrupar para rotación
      rotatingModelGroup = new THREE.Group();
      rotatingModelGroup.add(root);
      rotatingModelGroup.position.copy(MODEL_POSITION);
      scene.add(rotatingModelGroup);

      // Intento de completar texturas si faltan
      const [base1, base2, aoR, roughG, metalB] = await Promise.all([
        tryLoadTexture(TEX_BASE_1, THREE.SRGBColorSpace, false),
        tryLoadTexture(TEX_BASE_2, THREE.SRGBColorSpace, false),
        tryLoadTexture(TEX_AO_R,   null,                 false),
        tryLoadTexture(TEX_ROUGH_G,null,                 false),
        tryLoadTexture(TEX_METAL_B,null,                 false),
      ]);

      root.traverse(o => {
        if (!o.isMesh) return;
        const m = o.material; if (!m) return;
        if (!m.map && (base1 || base2)) {
          const chosen = base1 || base2;
          if (m.color) m.color.set(0xffffff);
          m.vertexColors = false;
          m.map = chosen;
        }
        if (!m.aoMap && aoR) {
          if (o.geometry && !o.geometry.attributes.uv2 && o.geometry.attributes.uv) {
            o.geometry.setAttribute('uv2', o.geometry.attributes.uv);
          }
          m.aoMap = aoR;
          m.aoMapIntensity = 1.0;
        }
        if (!m.roughnessMap && roughG) {
          m.roughnessMap = roughG;
          if (m.roughness === undefined) m.roughness = 1.0;
        }
        if (!m.metalnessMap && metalB) {
          m.metalnessMap = metalB;
          if (m.metalness === undefined) m.metalness = 0.9;
        }
        m.needsUpdate = true;
      });

      console.log('=== Materiales GLB (tras carga) ===');
      debugMaterials(root);
    }



    // ====== Input locomoción ======
    window.addEventListener('keydown', e=>{ if(setKey(e.code,true)) updateLocomotion(); });
    window.addEventListener('keyup', e=>{ if(setKey(e.code,false)) updateLocomotion(); });
    function setKey(code,p){ switch(code){ case 'KeyW': if(keys.w===p) return false; keys.w=p; return true; case 'KeyA': if(keys.a===p) return false; keys.a=p; return true; case 'KeyS': if(keys.s===p) return false; keys.s=p; return true; case 'KeyD': if(keys.d===p) return false; keys.d=p; return true; case 'ShiftLeft': case 'ShiftRight': if(keys.shift===p) return false; keys.shift=p; return true; default: return false; } }
    function decide() { if(keys.w && keys.shift && actions['Run']) return 'Run'; if(keys.w && actions['Walk']) return 'Walk'; if(keys.s && actions['Backwards']) return 'Backwards'; return 'Idle'; }
    function updateLocomotion(){ const next=decide(); if(next!==current && actions[next]) crossFade(next,0.18); }
    function crossFade(name,dur=0.25){ const prev=actions[current], next=actions[name]; if(!next) return; if(prev && prev!==next) prev.crossFadeTo(next,dur,false); next.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).play(); current=name; }

// ===== Controles móviles =====
const isMobile = matchMedia('(pointer: coarse)').matches || 'ontouchstart' in window;
const $mc = document.getElementById('mobileControls');
if (isMobile) {
  $mc.classList.remove('hidden');

  // (opcional) evita conflictos con OrbitControls en móvil
  if (typeof controls !== 'undefined' && controls) {
    controls.enablePan = false;
    // Si el pinch-zoom te molesta, descomenta:
    // controls.enableZoom = false;
  }

  const setMobileKey = (name, val) => {
    if (keys[name] !== val) { keys[name] = val; updateLocomotion?.(); }
  };

  const makeJoystick = (elem, onMove) => {
    const knob = elem.querySelector('.knob');
    let active = false, cx = 0, cy = 0;
    const MAX = 50;

    const place = (x, y) => {
      let dx = x - cx, dy = y - cy;
      const d = Math.hypot(dx, dy);
      if (d > MAX) { const k = MAX / d; dx *= k; dy *= k; }
      knob.style.transform = `translate(${dx}px, ${dy}px)`;
      onMove({ x: dx / MAX, y: dy / MAX, active });
    };

    const start = e => {
      active = true;
      const t = e.changedTouches[0];
      const r = elem.getBoundingClientRect();
      cx = r.left + r.width / 2; cy = r.top + r.height / 2;
      place(t.clientX, t.clientY);
      e.preventDefault();
    };
    const move = e => { if (!active) return;
      const t = e.changedTouches[0]; place(t.clientX, t.clientY); e.preventDefault();
    };
    const end = e => { if (!active) return;
      active = false; knob.style.transform = `translate(0px,0px)`; onMove({ x:0, y:0, active:false }); e.preventDefault();
    };

    elem.addEventListener('touchstart', start, { passive:false });
    window.addEventListener('touchmove',  move,  { passive:false });
    window.addEventListener('touchend',   end,   { passive:false });
    window.addEventListener('touchcancel',end,   { passive:false });
  };

  // Izquierdo: avanzar/retroceder (W/S) y freno
  makeJoystick(document.getElementById('joyL'), v => {
    setMobileKey('w', v.y < -0.25);
    setMobileKey('s', v.y >  0.25);
    // si quieres que el eje X también mueva lateral (no rotación), añade:
    // setMobileKey('a', v.x < -0.35);
    // setMobileKey('d', v.x >  0.35);
  });

  // Derecho: rotación del avatar (A/D)
  makeJoystick(document.getElementById('joyR'), v => {
    setMobileKey('a', v.x < -0.25);
    setMobileKey('d', v.x >  0.25);
  });

  // Botón RUN (mantener pulsado = Shift)
  const btnRun = document.getElementById('btnRun');
  const press = e => { setMobileKey('shift', true); e.preventDefault(); };
  const release = e => { setMobileKey('shift', false); e.preventDefault(); };
  btnRun.addEventListener('touchstart', press,   { passive:false });
  btnRun.addEventListener('touchend',   release, { passive:false });
  btnRun.addEventListener('touchcancel',release, { passive:false });

  // Ya que hay joysticks, no necesitamos WASD visuales de escritorio
  const help = document.getElementById('help'); if (help) help.style.display = 'none';
}




    // ====== Gestión segura de VideoTexture (evita ExternalTexture inactiva) ======
    function tickGalleryVideos() {
      for (const group of GALLERY.children) {
        const vTex = group?.userData?.videoTexture;
        const vMesh = group?.userData?.videoMesh;
        const video = group?.userData?.videoElement;
        if (!vTex || !vMesh || !video) continue;

        const ready = video.readyState >= 2 && !video.paused && !video.ended;
        // Si NO está listo, desconecta el map para que WebGPU no someta un ExternalTexture inválido
        if (!ready) {
          if (group.userData.videoMapAttached) {
            vMesh.material.map = null;
            group.userData.videoMapAttached = false;
            vMesh.material.needsUpdate = true;
          }
          // Intentar reanudar
          video.play().catch(()=>{});
          continue;
        }

        // Si está listo y el map no está asignado, lo reasignamos
        if (!group.userData.videoMapAttached) {
          vMesh.material.map = vTex;
          group.userData.videoMapAttached = true;
          vMesh.material.needsUpdate = true;
        }
        // Actualización segura
        vTex.needsUpdate = true;
      }
    }

    // ====== Loop ======
    const ROT_MODEL_SPEED = THREE.MathUtils.degToRad(MODEL_ROT_DEGS_PER_SEC);
    renderer.setAnimationLoop(()=>{
      const dt=clock.getDelta();

      // giro continuo del avatar con A/D
      let yaw=0; if(keys.a) yaw+=ROT_SPEED; if(keys.d) yaw-=ROT_SPEED; if(avatarRoot && yaw!==0) avatarRoot.rotation.y += yaw*dt;

      // movimiento del avatar
      let speed=0, sgn=0; if(current==='Run'){speed=RUN_SPEED; sgn=-1;} else if(current==='Walk'){speed=WALK_SPEED; sgn=-1;} else if(current==='Backwards'){speed=BACK_SPEED; sgn=+1;}
      if(avatarRoot && speed!==0){ const f=new THREE.Vector3(0,0,-1).applyQuaternion(avatarRoot.quaternion); f.y=0; f.normalize(); avatarRoot.position.addScaledVector(f, speed*sgn*dt); }

      // cámara sigue al avatar
      if(avatarRoot){ const t=new THREE.Vector3().copy(CAM_LOOK_AT).applyQuaternion(avatarRoot.quaternion).add(avatarRoot.position); controls.target.copy(t); }
      if(mixer) mixer.update(dt);

      // rotación del modelo GLB
      if (rotatingModelGroup) rotatingModelGroup.rotation.y += ROT_MODEL_SPEED * dt;

      // rotación del cubo demo
      if(cube) cube.rotation.y += 0.6*dt;

      updateInteractions();
      tickGalleryVideos();   // <-- protección VideoTexture
      controls.update(); stats.update();
      renderer.render(scene, camera);
    });

    // Resize
    window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // ====== Inicialización ======
    (async function init(){
      await loadRotatingModel();
    })();
  </script>
</body>
</html>
